-- Script COPYRIGHTED to | @tx.mor on DISCORD

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Screen dimensions for center clicking
local viewport = workspace.CurrentCamera.ViewportSize
local screenCenter = Vector2.new(viewport.X / 2, viewport.Y / 2)

-- Configuration
local Config = {
	KeyEndpoint = "https://pastefy.app/Mz3z3cSR/raw",
	Links = {
		WorkInk = "https://work.ink/1WZL/m38ctbyj",
		LootLabs = "https://loot-link.com/s?70755ac8",
		Discord = "https://discord.gg/23TMQnGBh3"
	},
	Colors = {
		Background = Color3.fromRGB(17, 24, 39),
		Primary = Color3.fromRGB(99, 102, 241),
		Secondary = Color3.fromRGB(55, 65, 81),
		Text = Color3.fromRGB(243, 244, 246),
		Success = Color3.fromRGB(34, 197, 94),
		Error = Color3.fromRGB(239, 68, 68),
		Accent = Color3.fromRGB(129, 140, 248)
	},
	AnimationConfig = {
		Duration = 0.3,
		EaseStyle = Enum.EasingStyle.Quad,
		EaseDirection = Enum.EasingDirection.Out
	}
}

-- Utility Functions
local Utility = {}

function Utility.CreateTween(object, properties, duration)
	local tweenInfo = TweenInfo.new(
		duration or Config.AnimationConfig.Duration,
		Config.AnimationConfig.EaseStyle,
		Config.AnimationConfig.EaseDirection
	)
	local tween = TweenService:Create(object, tweenInfo, properties)
	return tween
end

function Utility.CreateElement(className, properties)
	local element = Instance.new(className)
	for property, value in pairs(properties) do
		element[property] = value
	end
	return element
end

function Utility.ApplyRoundedCorners(instance, radius)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius or 12)
	corner.Parent = instance
	return corner
end

function Utility.ApplyGradient(instance, colors)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, colors[1]),
		ColorSequenceKeypoint.new(1, colors[2])
	})
	gradient.Parent = instance
	return gradient
end

-- Key System Class
local KeySystem = {}
KeySystem.__index = KeySystem

function KeySystem.new()
	local self = setmetatable({}, KeySystem)
	self.ValidKey = nil
	self.AttemptCount = 0
	self.MaxAttempts = 5
	self.IsAnimating = false
	self:Initialize()
	return self
end

function KeySystem:Initialize()
	self:CreateGui()
	self:SetupConnections()
	self:FetchKey()
end

function KeySystem:CreateGui()
	-- Main GUI Container
	self.Gui = Utility.CreateElement("ScreenGui", {
		Name = "KeySystem",
		ResetOnSpawn = false,
		IgnoreGuiInset = true,
		Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	})

	-- Background with blur effect
	self.Background = Utility.CreateElement("Frame", {
		Name = "Background",
		Size = UDim2.fromScale(1, 1),
		BackgroundColor3 = Config.Colors.Background,
		BackgroundTransparency = 0.3,
		Parent = self.Gui
	})

	-- Main container
	self.MainFrame = Utility.CreateElement("Frame", {
		Name = "MainFrame",
		Size = UDim2.fromOffset(400, 500),
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundColor3 = Config.Colors.Background,
		Parent = self.Gui
	})
	Utility.ApplyRoundedCorners(self.MainFrame, 16)
	Utility.ApplyGradient(self.MainFrame, {
		Config.Colors.Background,
		Color3.fromRGB(30, 41, 59)
	})

	-- Title and subtitle
	self.Title = Utility.CreateElement("TextLabel", {
		Name = "Title",
		Size = UDim2.new(1, 0, 0, 40),
		Position = UDim2.fromOffset(0, 30),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamBold,
		Text = "Key System",
		TextColor3 = Config.Colors.Text,
		TextSize = 28,
		Parent = self.MainFrame
	})

	self.Subtitle = Utility.CreateElement("TextLabel", {
		Size = UDim2.new(1, 0, 0, 30),
		Position = UDim2.new(0, 0, 0, 70),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamMedium,
		Text = "Please enter your key to continue",
		TextColor3 = Config.Colors.Text,
		TextSize = 16,
		TextTransparency = 0.3,
		Parent = self.MainFrame
	})

	-- Key input container
	self.InputContainer = Utility.CreateElement("Frame", {
		Size = UDim2.new(0.9, 0, 0, 50),
		Position = UDim2.new(0.5, 0, 0, 130),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundColor3 = Config.Colors.Secondary,
		Parent = self.MainFrame
	})
	Utility.ApplyRoundedCorners(self.InputContainer, 12)

	self.KeyInput = Utility.CreateElement("TextBox", {
		Size = UDim2.new(0.95, 0, 1, 0),
		Position = UDim2.fromScale(0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamMedium,
		PlaceholderText = "Enter your key here...",
		Text = "",
		TextColor3 = Config.Colors.Text,
		TextSize = 16,
		Parent = self.InputContainer
	})

	-- Method selector
	self.MethodLabel = Utility.CreateElement("TextLabel", {
		Size = UDim2.new(0.9, 0, 0, 30),
		Position = UDim2.new(0.5, 0, 0, 200),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamMedium,
		Text = "Select key method:",
		TextColor3 = Config.Colors.Text,
		TextSize = 16,
		TextXAlignment = Enum.TextXAlignment.Left,
		Parent = self.MainFrame
	})

	-- Method buttons
	self:CreateMethodButton("Work.ink", Config.Links.WorkInk, 250)
	self:CreateMethodButton("LootLabs", Config.Links.LootLabs, 310)

	-- Submit button
	self.SubmitButton = Utility.CreateElement("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 50),
		Position = UDim2.new(0.5, 0, 0, 380),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundColor3 = Config.Colors.Primary,
		Font = Enum.Font.GothamBold,
		Text = "Submit Key",
		TextColor3 = Config.Colors.Text,
		TextSize = 16,
		Parent = self.MainFrame
	})
	Utility.ApplyRoundedCorners(self.SubmitButton, 12)

	-- Discord button
	self.DiscordButton = Utility.CreateElement("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 40),
		Position = UDim2.new(0.5, 0, 0, 440),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundColor3 = Config.Colors.Secondary,
		Font = Enum.Font.GothamMedium,
		Text = "Join Discord",
		TextColor3 = Config.Colors.Text,
		TextSize = 14,
		Parent = self.MainFrame
	})
	Utility.ApplyRoundedCorners(self.DiscordButton, 12)

	-- Initial animation
	self:AnimateGuiAppearance()
end

function KeySystem:CreateMethodButton(text, link, yPos)
	local button = Utility.CreateElement("TextButton", {
		Size = UDim2.new(0.9, 0, 0, 50),
		Position = UDim2.new(0.5, 0, 0, yPos),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundColor3 = Config.Colors.Secondary,
		Font = Enum.Font.GothamMedium,
		Text = text,
		TextColor3 = Config.Colors.Text,
		TextSize = 16,
		Parent = self.MainFrame
	})
	Utility.ApplyRoundedCorners(button, 12)

	-- Hover effect
	button.MouseEnter:Connect(function()
		Utility.CreateTween(button, {
			BackgroundColor3 = Config.Colors.Accent
		}):Play()
	end)

	button.MouseLeave:Connect(function()
		Utility.CreateTween(button, {
			BackgroundColor3 = Config.Colors.Secondary
		}):Play()
	end)

	button.MouseButton1Click:Connect(function()
		if setclipboard then
			setclipboard(link)
			self:ShowNotification("Link copied to clipboard!", "Success")
		end
	end)
end

function KeySystem:ShowNotification(message, type)
	if self.NotificationFrame then
		self.NotificationFrame:Destroy()
	end

	local color = type == "Success" and Config.Colors.Success or Config.Colors.Error

	self.NotificationFrame = Utility.CreateElement("Frame", {
		Size = UDim2.new(0.9, 0, 0, 40),
		Position = UDim2.new(0.5, 0, 0, 180),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundColor3 = color,
		BackgroundTransparency = 0.8,
		Parent = self.MainFrame
	})
	Utility.ApplyRoundedCorners(self.NotificationFrame, 8)

	local notification = Utility.CreateElement("TextLabel", {
		Size = UDim2.fromScale(1, 1),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamMedium,
		Text = message,
		TextColor3 = Config.Colors.Text,
		TextSize = 14,
		Parent = self.NotificationFrame
	})

	-- Animate notification
	self.NotificationFrame.Position = UDim2.new(0.5, 0, 0, 160)
	self.NotificationFrame.BackgroundTransparency = 1
	notification.TextTransparency = 1

	Utility.CreateTween(self.NotificationFrame, {
		Position = UDim2.new(0.5, 0, 0, 180),
		BackgroundTransparency = 0.8
	}):Play()

	Utility.CreateTween(notification, {
		TextTransparency = 0
	}):Play()

	task.delay(2, function()
		if self.NotificationFrame then
			Utility.CreateTween(self.NotificationFrame, {
				Position = UDim2.new(0.5, 0, 0, 160),
				BackgroundTransparency = 1
			}):Play()

			Utility.CreateTween(notification, {
				TextTransparency = 1
			}):Play()

			task.delay(0.3, function()
				if self.NotificationFrame then
					self.NotificationFrame:Destroy()
				end
			end)
		end
	end)
end

function KeySystem:AnimateGuiAppearance()
	self.MainFrame.Position = UDim2.new(0.5, 0, 0.6, 0)
	self.MainFrame.BackgroundTransparency = 1
	self.Background.BackgroundTransparency = 1

	local elements = self.MainFrame:GetDescendants()
	for _, element in ipairs(elements) do
		if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			element.TextTransparency = 1
		end
		if element:IsA("Frame") and element ~= self.MainFrame then
			element.BackgroundTransparency = 1
		end
	end

	-- Animate background
	Utility.CreateTween(self.Background, {
		BackgroundTransparency = 0.3
	}):Play()

	-- Animate main frame
	Utility.CreateTween(self.MainFrame, {
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundTransparency = 0
	}):Play()

	-- Animate elements
	for _, element in ipairs(elements) do
		if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			Utility.CreateTween(element, {
				TextTransparency = element.Name == "Subtitle" and 0.3 or 0
			}):Play()
		end
		if element:IsA("Frame") and element ~= self.MainFrame then
			Utility.CreateTween(element, {
				BackgroundTransparency = 0
			}):Play()
		end
	end
end

function KeySystem:FetchKey()
	task.spawn(function()
		local success, response = pcall(function()
			return game:HttpGet(Config.KeyEndpoint)
		end)

		if success and response then
			self.ValidKey = response:gsub("%s+", "")
		else
			self:ShowNotification("Failed to fetch key. Please try again later.", "Error")
		end
	end)
end

function KeySystem:ValidateKey(inputKey)
	if not self.ValidKey then
		self:ShowNotification("Please wait for key validation system to initialize...", "Error")
		return false
	end

	self.AttemptCount = self.AttemptCount + 1

	if inputKey:gsub("%s+", "") == self.ValidKey then
		return true
	end

	if self.AttemptCount >= self.MaxAttempts then
		self:ShowNotification("Too many attempts. Please get a new key.", "Error")
		task.wait(2)
		self:HandleMaxAttempts()
		return false
	end

	self:ShowNotification("Invalid key! Attempt " .. self.AttemptCount .. "/" .. self.MaxAttempts, "Error")
	return false
end

function KeySystem:HandleMaxAttempts()
	-- Disable input
	self.KeyInput.TextEditable = false
	self.SubmitButton.AutoButtonColor = false

	-- Visual feedback
	Utility.CreateTween(self.KeyInput, {
		TextColor3 = Config.Colors.Error
	}):Play()

	Utility.CreateTween(self.SubmitButton, {
		BackgroundColor3 = Config.Colors.Secondary,
		TextColor3 = Color3.fromRGB(150, 150, 150)
	}):Play()

	-- Reset after cooldown
	task.delay(30, function()
		if self.Gui.Parent then
			self.AttemptCount = 0
			self.KeyInput.TextEditable = true
			self.SubmitButton.AutoButtonColor = true

			Utility.CreateTween(self.KeyInput, {
				TextColor3 = Config.Colors.Text
			}):Play()

			Utility.CreateTween(self.SubmitButton, {
				BackgroundColor3 = Config.Colors.Primary,
				TextColor3 = Config.Colors.Text
			}):Play()

			self:ShowNotification("You can try again now.", "Success")
		end
	end)
end

function KeySystem:HandleKeySuccess()
	self.IsAnimating = true

	-- Disable inputs during animation
	self.KeyInput.TextEditable = false
	self.SubmitButton.AutoButtonColor = false

	-- Show success feedback
	self:ShowNotification("Key validated successfully!", "Success")

	-- Enable DraculaHubGUI
	local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	local draculaHubGui = playerGui:FindFirstChild("DraculaHubScreenGUI")
	local main = draculaHubGui:FindFirstChild("DraculaHubGUI")

	if main then
		main.Visible = true -- Ensure this matches the GUI's structure
	else
		warn("DraculaHubGUI not found!")
	end

	-- Clean up key system GUI
	self:CleanupAndDestroy()
end


function KeySystem:SetupConnections()
	-- Submit button clicking
	self.SubmitButton.MouseButton1Click:Connect(function()
		if self.IsAnimating then return end

		local inputKey = self.KeyInput.Text
		if self:ValidateKey(inputKey) then
			self:HandleKeySuccess()
		end
	end)

	-- Enter key pressing
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
			if self.KeyInput:IsFocused() and not self.IsAnimating then
				local inputKey = self.KeyInput.Text
				if self:ValidateKey(inputKey) then
					self:HandleKeySuccess()
				end
			end
		end
	end)

	-- Discord button
	self.DiscordButton.MouseButton1Click:Connect(function()
		if setclipboard then
			setclipboard(Config.Links.Discord)
			self:ShowNotification("Discord link copied to clipboard!", "Success")
		end
	end)

	-- Button hover effects
	local buttons = {
		self.SubmitButton,
		self.DiscordButton
	}

	for _, button in ipairs(buttons) do
		button.MouseEnter:Connect(function()
			if self.IsAnimating then return end

			Utility.CreateTween(button, {
				BackgroundColor3 = button == self.SubmitButton and 
					Config.Colors.Accent or 
					Color3.fromRGB(75, 85, 101)
			}):Play()
		end)

		button.MouseLeave:Connect(function()
			if self.IsAnimating then return end

			Utility.CreateTween(button, {
				BackgroundColor3 = button == self.SubmitButton and 
					Config.Colors.Primary or 
					Config.Colors.Secondary
			}):Play()
		end)
	end
end

function KeySystem:HandleSecurityViolation()
	self:ShowNotification("Security violation detected!", "Error")
	task.wait(1)
	self:CleanupAndDestroy()
end

function KeySystem:CleanupAndDestroy()
	self.IsDestroying = true

	-- Find the DraculaHub GUI
	local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
	local draculaHub = playerGui:WaitForChild("DraculaHubScreenGUI")
	local mainGui = draculaHub:WaitForChild("DraculaHubGUI")
	local keyGui = playerGui:WaitForChild("KeySystem")

	-- Show DraculaHub GUI
	if mainGui then
		mainGui.Visible = true
		
		if mainGui.Visible == true then
			while task.wait(0.1) do
				if keyGui then
					keyGui:Destroy()
				else
					break
				end
			end
		end
	else
		warn("DraculaHubGUI not found!")
	end

	-- Animate fade-out for KeySystem GUI
	local elements = self.MainFrame:GetDescendants()
	for _, element in ipairs(elements) do
		if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			Utility.CreateTween(element, {
				TextTransparency = 1
			}):Play()
		end
		if element:IsA("Frame") then
			Utility.CreateTween(element, {
				BackgroundTransparency = 1
			}):Play()
		end
	end

	Utility.CreateTween(self.Background, {
		BackgroundTransparency = 1
	}):Play()

	Utility.CreateTween(self.MainFrame, {
		Position = UDim2.new(0.5, 0, 0.6, 0),
		BackgroundTransparency = 1
	}).Completed:Connect(function()
		-- Destroy the entire KeySystem GUI
		self.Gui:Destroy()
		self.MainFrame:Destroy()
	end)
end

-- Initialize the key system
local function InitializeKeySystem(onSuccess)
	local keySystem = KeySystem.new()
	keySystem.OnSuccess = onSuccess
	return keySystem
end

task.spawn(InitializeKeySystem)

--Main GUI
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local playerGui = player.PlayerGui
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Configuration
local Config = {
	Colors = {
		Background = Color3.fromRGB(17, 24, 39),
		Primary = Color3.fromRGB(99, 102, 241),
		Secondary = Color3.fromRGB(55, 65, 81),
		Text = Color3.fromRGB(243, 244, 246),
		Success = Color3.fromRGB(34, 197, 94),
		Error = Color3.fromRGB(239, 68, 68),
		Accent = Color3.fromRGB(129, 140, 248)
	},
	AnimationConfig = {
		Duration = 0.3,
		EaseStyle = Enum.EasingStyle.Quad,
		EaseDirection = Enum.EasingDirection.Out
	}
}

-- Create main GUI elements
local gui = Instance.new("ScreenGui")
local mainFrame = Instance.new("Frame")
local topBar = Instance.new("Frame")
local title = Instance.new("TextLabel")
local closeButton = Instance.new("ImageButton")
local creditsLabel = Instance.new("TextLabel")
local separator = Instance.new("Frame")
local separator2 = Instance.new("Frame")
local spamButton = Instance.new("TextButton")
local speedButton = Instance.new("TextButton")
local jumpButton = Instance.new("TextButton")
local redeemCodesButton = Instance.new("TextButton")
local healthRegenButton = Instance.new("TextButton")
local teleportButton = Instance.new("TextButton")
local fruitsDropdownButton = Instance.new("TextButton")

gui.ResetOnSpawn = false
gui.Name = "DraculaHubScreenGUI"
gui.IgnoreGuiInset = true
gui.DisplayOrder = 16

-- Style the main frame with modern theme
mainFrame.Name = "DraculaHubGUI"
mainFrame.Size = UDim2.new(0.2, 0, 0.545, 0)
mainFrame.Position = UDim2.new(0.5, -175, 0.5, -200)
mainFrame.BackgroundColor3 = Config.Colors.Background
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Visible = false

-- Style the top bar
topBar.Size = UDim2.new(1, 0, 0.085, 0)
topBar.BackgroundColor3 = Config.Colors.Secondary
topBar.BorderSizePixel = 0

-- Title styling
title.Size = UDim2.new(1, -30, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Dracula Hub"
title.TextColor3 = Config.Colors.Text
title.TextSize = 20
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left

-- Close button styling
closeButton.Size = UDim2.new(0, 35, 0, 35)
closeButton.Position = UDim2.new(1, -40, 0.5, -17.5)
closeButton.BackgroundTransparency = 1
closeButton.Image = "rbxassetid://7072725342"
closeButton.ImageColor3 = Config.Colors.Text

-- Credits styling
creditsLabel.Size = UDim2.new(1, 0, 0, 20)
creditsLabel.Position = UDim2.new(0, 0, 0.94, 0)
creditsLabel.BackgroundTransparency = 1
creditsLabel.Text = "by: tx.mor | on Discord"
creditsLabel.TextColor3 = Config.Colors.Text
creditsLabel.TextSize = 16
creditsLabel.Font = Enum.Font.GothamBold
creditsLabel.TextXAlignment = Enum.TextXAlignment.Center

-- Separator styling
separator.Size = UDim2.new(0.9, 0, 0.005, 0)
separator.Position = UDim2.new(0.05, 0, 0.435, 0)
separator.BackgroundColor3 = Config.Colors.Secondary
separator.BorderSizePixel = 0

separator2.Size = UDim2.new(0.9, 0, 0.005, 0)
separator2.Position = UDim2.new(0.05, 0, 0.695, 0)
separator2.BackgroundColor3 = Config.Colors.Secondary
separator2.BorderSizePixel = 0

-- Function to set button properties with modern styling
local function setButtonProperties(button, text, position)
	button.Size = UDim2.new(0.9, 0, 0, 50)
	button.Position = position
	button.BackgroundColor3 = Config.Colors.Secondary
	button.TextColor3 = Config.Colors.Text
	button.TextSize = 18
	button.Font = Enum.Font.GothamSemibold
	button.BorderSizePixel = 0
	button.Text = text

	-- Apply corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = button
end

-- Function to create button animations
local function createButtonTween(button, color)
	return TweenService:Create(
		button,
		TweenInfo.new(Config.AnimationConfig.Duration, Config.AnimationConfig.EaseStyle, Config.AnimationConfig.EaseDirection),
		{BackgroundColor3 = color}
	)
end

-- Style buttons with modern theme
local function styleButton(button, text, position, isExempt)
	setButtonProperties(button, text, position)

	-- Create tweens
	local hoverInTween = createButtonTween(button, Config.Colors.Accent)
	local hoverOutTween = createButtonTween(button, Config.Colors.Secondary)
	local activeTween = createButtonTween(button, Config.Colors.Primary)
	local inactiveTween = createButtonTween(button, Config.Colors.Secondary)

	-- Track button state
	local isActive = false
	local canClick = true

	button.MouseEnter:Connect(function()
		if not isActive and not isExempt then
			hoverInTween:Play()
		end
	end)

	button.MouseLeave:Connect(function()
		if not isActive and not isExempt then
			hoverOutTween:Play()
		end
	end)

	-- Toggle function with cooldown
	local function toggleButtonState()
		if not canClick then return end
		if isExempt then return end

		isActive = not isActive
		if isActive then
			activeTween:Play()
		else
			inactiveTween:Play()
		end

		canClick = false
		task.wait(0.15)
		canClick = true
	end

	button.MouseButton1Click:Connect(toggleButtonState)
end

-- Apply modern styling to all buttons
styleButton(spamButton, "Auto farm", UDim2.new(0.05, 0, 0.133, 0))
styleButton(speedButton, "Speed Boost", UDim2.new(0.05, 0, 0.471, 0))
styleButton(jumpButton, "Jump Boost", UDim2.new(0.05, 0, 0.578, 0))
styleButton(redeemCodesButton, "Redeem All Codes", UDim2.new(0.05, 0, 0.322, 0), true)
styleButton(healthRegenButton, "Health Regen", UDim2.new(0.05, 0, 0.729, 0))
styleButton(teleportButton, "Teleport", UDim2.new(0.05, 0, 0.837, 0))
styleButton(fruitsDropdownButton, "Spin Fruits", UDim2.new(0.05, 0, 0.228, 0))

-- Add modern rounded corners
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 16)
mainCorner.Parent = mainFrame

local topCorner = Instance.new("UICorner")
topCorner.CornerRadius = UDim.new(0, 16)
topCorner.Parent = topBar

-- Apply gradient to main frame
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Config.Colors.Background),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 41, 59))
})
gradient.Parent = mainFrame

-- Parent elements
topBar.Parent = mainFrame
title.Parent = topBar
closeButton.Parent = topBar
creditsLabel.Parent = mainFrame
separator.Parent = mainFrame
separator2.Parent = mainFrame
spamButton.Parent = mainFrame
speedButton.Parent = mainFrame
jumpButton.Parent = mainFrame
redeemCodesButton.Parent = mainFrame
healthRegenButton.Parent = mainFrame
teleportButton.Parent = mainFrame
fruitsDropdownButton.Parent = mainFrame
mainFrame.Parent = gui
gui.Parent = playerGui

-- Track states
local isSpeedBoostActive = false
local isJumpBoostActive = false
local isSpamActive = false
local spamLoop

local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
local isSpeedBoostActive = false
local isJumpBoostActive = false

-- Ensure buttons reset correctly
local function updateSpeedBoost(humanoid)
	if isSpeedBoostActive then
		humanoid.WalkSpeed = 200
		speedButton.Text = "Speed Boost Active"
	else
		humanoid.WalkSpeed = 16
		speedButton.Text = "Speed Boost"
	end
end

local function updateJumpBoost(humanoid)
	if isJumpBoostActive then
		humanoid.JumpPower = 200
		jumpButton.Text = "Jump Boost Active"
	else
		humanoid.JumpPower = 50
		jumpButton.Text = "Jump Boost"
	end
end

-- Toggle speed boost
local function toggleSpeedBoost()
	local humanoid = character:WaitForChild("Humanoid")
	isSpeedBoostActive = not isSpeedBoostActive
	updateSpeedBoost(humanoid)

	if isSpeedBoostActive then
		spawn(function()
			while isSpeedBoostActive and humanoid.Parent do
				humanoid.WalkSpeed = 200
				wait(0.1)
			end
		end)
	end
end

-- Toggle jump boost
local function toggleJumpBoost()
	local humanoid = character:WaitForChild("Humanoid")
	isJumpBoostActive = not isJumpBoostActive
	updateJumpBoost(humanoid)

	if isJumpBoostActive then
		spawn(function()
			while isJumpBoostActive and humanoid.Parent do
				humanoid.JumpPower = 200
				wait(0.1)
			end
		end)
	end
end

-- Reset boosts on respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	local humanoid = character:WaitForChild("Humanoid")
	updateSpeedBoost(humanoid)
	updateJumpBoost(humanoid)
end)

local keySequence = {Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four, Enum.KeyCode.Five, Enum.KeyCode.Six, Enum.KeyCode.Seven, Enum.KeyCode.Eight}
local keyIndex = 1
local isSpamActive = false
local autoFarmThread
local positionLockThread

-- Optimize click simulation with pre-calculated position
local screenSize = workspace.CurrentCamera.ViewportSize
local clickPos = Vector2.new(screenSize.X * 0.95, screenSize.Y * 0.95)

-- Optimized simulation functions
local function simulateClick()
	VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, true, game, 0)
	VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, false, game, 0)
end

local function simulateKeyPressAndClick(keyCode)
	VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
	VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
	simulateClick()
end

-- Platform management functions
local function createPlatform(position)
	local part = Instance.new("Part")
	part.Name = "AutoFarmPlatform"
	part.Size = Vector3.new(100, 1, 100)
	part.Position = position
	part.Anchored = true
	part.Parent = workspace
	return part
end

local function cleanupPlatform()
	local platform = workspace:FindFirstChild("AutoFarmPlatform")
	if platform then
		platform:Destroy()
	end
end

-- Separate function for spamming keys and clicking
local function spamKeysAndClick()
	while isSpamActive do
		simulateKeyPressAndClick(keySequence[keyIndex])
		keyIndex = (keyIndex % #keySequence) + 1
		task.wait(0.28)  -- Interval between key and click spam
	end
end

-- Function to safely teleport player and anchor over platform
local function teleportAndAnchorPlayer(position)
	local player = game.Players.LocalPlayer
	if not player then return end

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if humanoidRootPart then
		humanoidRootPart.CFrame = position
		task.wait(0.5)  -- Give time to stabilize position
		humanoidRootPart.Anchored = true
	end
end

-- Function to lock player position while auto-farming
local function lockPlayerPosition(position)
	positionLockThread = task.spawn(function()
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

		while isSpamActive do
			if humanoidRootPart.Position ~= position.Position then
				humanoidRootPart.CFrame = position
				humanoidRootPart.Anchored = true
			end
			task.wait(0.1)  -- Frequency of position checking
		end
	end)
end

-- Main toggle function with safe teleport
local function toggleSpam()
	local character = game.Players.LocalPlayer.Character
	if not character then return end

	local hrm = character:WaitForChild("HumanoidRootPart")
	if not hrm then return end

	local initialPosition = hrm.Position

	if isSpamActive then
		isSpamActive = false
		spamButton.Text = "Auto farm"
		if autoFarmThread then
			task.cancel(autoFarmThread)
			autoFarmThread = nil
		end
		if positionLockThread then
			task.cancel(positionLockThread)
			positionLockThread = nil
		end
		cleanupPlatform()
		hrm.Anchored = false
		hrm.CFrame = CFrame.new(initialPosition)
	else
		isSpamActive = true
		spamButton.Text = "Auto farm Active"

		local newPosition = Vector3.new(5000, 5000, 0)
		local platformPosition = newPosition - Vector3.new(0, character.Humanoid.HipHeight + 7, 0)
		createPlatform(platformPosition)

		local targetPosition = CFrame.new(newPosition)
		teleportAndAnchorPlayer(targetPosition)
		lockPlayerPosition(targetPosition)

		autoFarmThread = task.spawn(spamKeysAndClick)
	end
end

-- Emergency stop hotkey
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.P and isSpamActive then
		toggleSpam()
	end
end)

-- Cleanup on character respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	if isSpamActive then
		toggleSpam()
		toggleSpam() -- Double call ensures proper restart in case of respawn
	end
end)

--redeem Codes function
local function redeemCodesFunc()
	for _, k in pairs(game.Players:GetChildren()) do
		for _, v in pairs(k["MAIN_DATA"].Codes:GetChildren()) do
			print(v.Value)
			local ohString1 = "Codes"
			local ohString2 = "Redeem"
			local ohTable3 = {
				["Code"] = v.Value,
			}

			game:GetService("ReplicatedStorage").Replicator:InvokeServer(ohString1, ohString2, ohTable3)
		end
	end
end

-- Enhanced Health Regen Feature with Server Resistance Handling
local isHealthRegenActive = false
local baseRegenAmount = 700
local regenAmount = baseRegenAmount
local regenInterval = 0.1
local maxRegenAmount = 1300
local regenIncreaseRate = 5000
local cooldown = 1.5

local desiredHealth = 0 -- Tracks intended health to counter server resistance
local lastToggleTime = 0

local function toggleHealthRegen()
	if tick() - lastToggleTime < cooldown then
		return
	end
	lastToggleTime = tick()

	isHealthRegenActive = not isHealthRegenActive
	if isHealthRegenActive then
		healthRegenButton.Text = "Health Regen Active"
		spawn(function()
			while isHealthRegenActive do
				if character and character:FindFirstChild("Humanoid") then
					local humanoid = character.Humanoid
					-- Only regenerate if health is less than max health
					if humanoid.Health < humanoid.MaxHealth then
						-- Calculate the intended health after regeneration
						local regenThisTick = math.min(regenAmount, humanoid.MaxHealth - humanoid.Health)
						desiredHealth = math.min(humanoid.MaxHealth, humanoid.Health + regenThisTick)

						-- Set health to desired amount to counter server resistance
						humanoid.Health = desiredHealth

						-- Increase regen amount over time, capped at maxRegenAmount
						regenAmount = math.min(maxRegenAmount, regenAmount + regenIncreaseRate)
					else
						-- Reset regen amount to base when fully healed
						regenAmount = baseRegenAmount
						desiredHealth = humanoid.MaxHealth -- Update desired health to max
					end
				end
				-- Periodically check and correct health if it's being resisted by the server
				if character and character:FindFirstChild("Humanoid") and isHealthRegenActive then
					local humanoid = character.Humanoid
					if humanoid.Health < desiredHealth then
						humanoid.Health = desiredHealth -- Forcefully set to desired health
					end
				end
				wait(regenInterval)
			end
		end)
	else
		healthRegenButton.Text = "Health Regen"
		regenAmount = baseRegenAmount
		desiredHealth = 0 -- Reset desired health
	end
end

-- Define teleport dropdown frame
local dropdownFrame = Instance.new("Frame")
dropdownFrame.Size = UDim2.new(0.9, 0,0.3, 0) 
dropdownFrame.Position = UDim2.new(1.02, 0,0.78, 0)
dropdownFrame.BackgroundColor3 = Color3.fromRGB(35, 37, 49)
dropdownFrame.BorderSizePixel = 0
dropdownFrame.Visible = false

local dropdownCorner = Instance.new("UICorner")
dropdownCorner.CornerRadius = UDim.new(0.15, 0)
dropdownCorner.Parent = dropdownFrame

-- Add a UIListLayout to organize buttons vertically
local listLayout = Instance.new("UIListLayout")
listLayout.Parent = dropdownFrame
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
listLayout.VerticalAlignment = Enum.VerticalAlignment.Center
listLayout.Padding = UDim.new(0.04, 0)

-- Function to safely teleport player
local function teleportPlayer(position)
	local player = game.Players.LocalPlayer
	if not player then return end

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

	if humanoidRootPart then
		humanoidRootPart.CFrame = position
	end
end

-- Predefined locations (using CFrame for proper teleportation)
local locations = {
	["Marco Boss Spawn"] = CFrame.new(-856.22, 960.18, 442.76),
	["Colosseum"] = CFrame.new(506.42, 742.67, 802.55),
	["Second Sea Teleporter"] = CFrame.new(1143.21, 733.25, 1014.47)
}

-- Function to create a teleport button
local function createLocationButton(name, position)
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(1, -10, 0, 30)
	button.BackgroundColor3 = Color3.fromRGB(68, 71, 90)
	button.TextColor3 = Color3.fromRGB(248, 248, 242)
	button.TextSize = 16
	button.Font = Enum.Font.GothamSemibold
	button.Text = name
	button.Parent = dropdownFrame
	button.LayoutOrder = #dropdownFrame:GetChildren()

	-- Add rounded corners to button
	local buttonCorner = Instance.new("UICorner")
	buttonCorner.CornerRadius = UDim.new(0, 6)
	buttonCorner.Parent = button

	-- Hover effects
	button.MouseEnter:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {
			BackgroundColor3 = Color3.fromRGB(78, 81, 100)
		}):Play()
	end)

	button.MouseLeave:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {
			BackgroundColor3 = Color3.fromRGB(68, 71, 90)
		}):Play()
	end)

	-- Click handler for teleportation
	button.MouseButton1Click:Connect(function()
		teleportPlayer(position)
		teleportButton.Text = "Teleport"
		teleportButton.BackgroundColor3 = Color3.fromRGB(68, 71, 90)
		dropdownFrame.Visible = false -- Hide dropdown after teleporting
		print("Teleported to: " .. name)
	end)
end

-- Create buttons for all locations
for locationName, locationCFrame in pairs(locations) do
	createLocationButton(locationName, locationCFrame)
end

-- Auto-adjust frame height based on content
local function updateDropdownHeight()
	local contentHeight = listLayout.AbsoluteContentSize.Y
	dropdownFrame.Size = UDim2.new(0.9, 0, 0, contentHeight + 20)
end

listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateDropdownHeight)
updateDropdownHeight()

-- Toggle dropdown visibility only with teleport button
teleportButton.MouseButton1Click:Connect(function()
	dropdownFrame.Visible = not dropdownFrame.Visible

	if dropdownFrame.Visible == true then
		teleportButton.Text = "Teleport Hide"
	else
		teleportButton.Text = "Teleport"
	end
end)

-- Parent dropdown frame to main frame
dropdownFrame.Parent = mainFrame

-- GUI Cleanup on Respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	if isHealthRegenActive then toggleHealthRegen() toggleHealthRegen() end
end)

-- Function to create a dropdown for selecting fruits
local function createFruitDropdown(parentFrame, position, size)
	-- Dropdown for Fruits
	local dropdownFrame = Instance.new("Frame")
	dropdownFrame.Size = size or UDim2.new(0.9, 0, 0.3, 0)
	dropdownFrame.Position = position or UDim2.new(-0.93, 0, 0.005, 130)
	dropdownFrame.BackgroundColor3 = Color3.fromRGB(35, 37, 49)
	dropdownFrame.BorderSizePixel = 0
	dropdownFrame.Visible = false
	dropdownFrame.Parent = parentFrame

	local dropdownCorner = Instance.new("UICorner")
	dropdownCorner.CornerRadius = UDim.new(0.05, 0)
	dropdownCorner.Parent = dropdownFrame

	-- Create a ScrollingFrame to hold fruit buttons
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Size = UDim2.new(1, 0, 0.85, 0)
	scrollFrame.Position = UDim2.new(0, 0, 0.05, 0)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.CanvasSize = UDim2.new(0, 0, 1, 0)
	scrollFrame.Parent = dropdownFrame

	-- Center the scrolling frame's contents
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	listLayout.Padding = UDim.new(0.01, 0)
	listLayout.Parent = scrollFrame

	-- Add a button to start/stop spinning
	local toggleSpinButton = Instance.new("TextButton")
	toggleSpinButton.Size = UDim2.new(0.9, 0, 0, 40)
	toggleSpinButton.Position = UDim2.new(0.05, 0, 1.05, 0)
	toggleSpinButton.Text = "Start Spinning"
	toggleSpinButton.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
	toggleSpinButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleSpinButton.Font = Enum.Font.GothamBold
	toggleSpinButton.TextSize = 16
	toggleSpinButton.Parent = dropdownFrame

	local toggleSpinButtonCorner = Instance.new("UICorner")
	toggleSpinButtonCorner.CornerRadius = UDim.new(0.15, 0)
	toggleSpinButtonCorner.Parent = toggleSpinButton

	-- Fruit selection logic
	local wantedFruits = {}
	local fruitList = {
		"TSRubber",
		"Gravity",
		"Quake",
		"Phoenix",
		"FlameV2",
		"MagmaV2",
		"Dough",
		"Dragon",
		"DragonV2",
		"Magnet",
		"Venom",
		"IceV2",
		"LightV2",
		"Lightning",
		"Leopard",
		"Ope",
		"Nika",
		"Soul",
		"DarkXQuake",
		"Okuchi",
	}

	-- Create fruit buttons with toggle functionality inside scrollFrame
	for _, fruit in ipairs(fruitList) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(1, -10, 0, 30)
		button.BackgroundColor3 = Color3.fromRGB(68, 71, 90)
		button.TextColor3 = Color3.fromRGB(248, 248, 242)
		button.TextSize = 16
		button.Font = Enum.Font.GothamSemibold
		button.Text = fruit
		button.Parent = scrollFrame

		-- Add rounded corners
		local buttonCorner = Instance.new("UICorner")
		buttonCorner.CornerRadius = UDim.new(0, 6)
		buttonCorner.Parent = button

		-- Toggle button state and update wantedFruits
		local isActive = false
		button.MouseButton1Click:Connect(function()
			isActive = not isActive
			if isActive then
				button.BackgroundColor3 = Color3.fromRGB(80, 200, 120) -- Active color (green)
				table.insert(wantedFruits, fruit)
			else
				button.BackgroundColor3 = Color3.fromRGB(68, 71, 90) -- Inactive color
				for i, v in ipairs(wantedFruits) do
					if v == fruit then
						table.remove(wantedFruits, i)
						break
					end
				end
			end
		end)
	end

	-- Update scrollFrame CanvasSize based on content
	local function updateCanvasSize()
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
	end
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvasSize)
	updateCanvasSize()

	-- Create the dropdown toggle button
	local dropdownToggleButton = fruitsDropdownButton

	-- Toggle dropdown visibility with animation
	dropdownToggleButton.MouseButton1Click:Connect(function()
		if dropdownFrame.Visible then
			dropdownToggleButton.Text = "Spin Fruits"
		else
			dropdownToggleButton.Text = "Hide Spin Fruits"
		end
		dropdownFrame.Visible = not dropdownFrame.Visible
	end)

	-- Define spinning state and function reference
	local spinning = false
	local spinCoroutine

	-- Instruction label to inform the player
	local instructionLabel = Instance.new("TextLabel")
	instructionLabel.Size = UDim2.new(1, 0, 0, 20)
	instructionLabel.Position = UDim2.new(0, 0, -0.15, 0)
	instructionLabel.Text = ""
	instructionLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
	instructionLabel.TextSize = 14
	instructionLabel.BackgroundTransparency = 1
	instructionLabel.Parent = dropdownFrame

	-- Function to handle the spinning process
	local function spinForWantedFruits()
		local target = game:GetService("ReplicatedStorage").Replicator
		local spinCommand = { "FruitsHandler", "Spin", {} }

		-- Coroutine to manage spinning
		spinCoroutine = coroutine.create(function()
			while spinning do
				local foundWantedFruit = false
				for slot = 1, 8 do -- Check all 8 slots
					local success, currFruit = pcall(function()
						return game.Players.LocalPlayer["MAIN_DATA"].Slots[tostring(slot)].Value
					end)

					if not success then
						wait(2) -- Wait before retrying
						continue
					end

					-- Check if current fruit in slot matches any in wantedFruits (case-insensitive)
					for _, wantedFruit in ipairs(wantedFruits) do
						if string.lower(currFruit) == string.lower(wantedFruit) then
							foundWantedFruit = true
							break
						end
					end

					if foundWantedFruit then break end
				end

				-- Stop spinning if we found a wanted fruit
				if foundWantedFruit then
					print("Acquired a desired fruit!")
					spinning = false
					toggleSpinButton.Text = "Start Spinning"
					toggleSpinButton.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
					instructionLabel.Text = "You have acquired a wanted fruit. Remove it to spin again."
					return
				end

				-- Attempt to spin and check for errors
				local spinSuccess = pcall(function()
					target:InvokeServer(unpack(spinCommand))
				end)

				if not spinSuccess then
					print("Spin attempt failed, retrying...")
					wait(2) -- Wait before retrying spin
					continue
				end

				wait(5.5) -- Delay between spins to prevent server overload
			end
		end)

		coroutine.resume(spinCoroutine)
	end

	-- Toggle spinning state with the button
	toggleSpinButton.MouseButton1Click:Connect(function()
		local hasWantedFruit = false
		for slot = 1, 8 do
			local success, currFruit = pcall(function()
				return game.Players.LocalPlayer["MAIN_DATA"].Slots[tostring(slot)].Value
			end)

			if success then
				for _, wantedFruit in ipairs(wantedFruits) do
					if string.lower(currFruit) == string.lower(wantedFruit) then
						hasWantedFruit = true
						break
					end
				end
			end

			if hasWantedFruit then
				instructionLabel.Text = "You already have a wanted fruit. Remove it to spin again."
				return
			end
		end

		if spinning then
			spinning = false
			toggleSpinButton.Text = "Start Spinning"
			toggleSpinButton.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
			instructionLabel.Text = ""
			print("Spinning stopped.")
		else
			if #wantedFruits > 0 then
				spinning = true
				toggleSpinButton.Text = "Stop Spinning"
				toggleSpinButton.BackgroundColor3 = Color3.fromRGB(200, 80, 80)
				instructionLabel.Text = ""
				print("Spinning started.")
				spinForWantedFruits()
			else
				instructionLabel.Text = "Select at least one fruit to start spinning."
			end
		end
	end)
end

spamButton.MouseButton1Click:Connect(toggleSpam)
speedButton.MouseButton1Click:Connect(toggleSpeedBoost)
jumpButton.MouseButton1Click:Connect(toggleJumpBoost)
redeemCodesButton.MouseButton1Click:Connect(redeemCodesFunc)
healthRegenButton.MouseButton1Click:Connect(toggleHealthRegen)
fruitsDropdownButton.MouseButton1Click:Connect(createFruitDropdown(mainFrame, UDim2.new(-0.93, 0, 0.005, 130), UDim2.new(0.9, 0, 0.3, 0)))
closeButton.MouseButton1Click:Connect(function()
	mainFrame:Destroy()
end)

-- Update screen center if viewport size changes
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
	screenCenter = Vector2.new(viewport.X / 2, viewport.Y / 2)
end)
